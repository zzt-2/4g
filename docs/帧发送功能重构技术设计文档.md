# å¸§å‘é€åŠŸèƒ½é‡æ„æŠ€æœ¯è®¾è®¡æ–‡æ¡£

## 1. ç°æœ‰å®ç°å‡†ç¡®åˆ†æ

### 1.1 å®é™…ä½¿ç”¨çš„åŠŸèƒ½ âœ…

- **sendFrameInstancesStore.ts** - åŸºäºPiniaçš„å®ä¾‹çŠ¶æ€ç®¡ç†
- **sendFrameInsComposable.ts** - æä¾›å®Œæ•´çš„CRUDå’Œç¼–è¾‘åŠŸèƒ½
- **å®é™…ä½¿ç”¨çš„æ–¹æ³•**ï¼š
  - `fetchInstances()` - ä»åç«¯APIåŠ è½½å®ä¾‹ï¼ˆé¡µé¢åˆå§‹åŒ–æ—¶è°ƒç”¨ï¼‰
  - `updateInstance()` / `saveEditedInstance()` - ä¿å­˜å•ä¸ªå®ä¾‹ä¿®æ”¹
  - `createInstance()`, `deleteInstance()`, `copyInstance()` - åŸºç¡€CRUDæ“ä½œ

### 1.2 æ–‡ä»¶æ“ä½œåŠŸèƒ½åˆ†æ ğŸ“‹

- **dataStorageAPI.sendInstances**ï¼š
  - `export()` / `import()` - ç”¨äºåº”ç”¨æ•°æ®çš„å›ºå®šè·¯å¾„å¯¼å…¥å¯¼å‡º
  - å½“å‰åœ¨Composableä¸­å®ç°ï¼Œä¸»è¦ç”¨äºå®ä¾‹æ•°æ®çš„å¤‡ä»½æ¢å¤
- **filesAPI**ï¼š
  - `saveJsonToFile()` / `loadJsonFromFile()` - ç”¨æˆ·è‡ªé€‰è·¯å¾„çš„æ–‡ä»¶æ“ä½œ
  - é€‚åˆç”¨äºé…ç½®æ–‡ä»¶çš„ä¿å­˜å’ŒåŠ è½½

### 1.3 å½“å‰é…ç½®æµç¨‹

```
ç”¨æˆ·æ“ä½œ â†’ StoreçŠ¶æ€æ›´æ–° â†’ è°ƒç”¨Composableæ–¹æ³• â†’ è°ƒç”¨electronApi â†’ åç«¯æŒä¹…åŒ–
```

**å•å¸§é…ç½®**ï¼šæ²¡æœ‰ç‹¬ç«‹çš„é…ç½®ä¿å­˜ï¼Œåªæ˜¯å®ä¾‹å‚æ•°çš„ä¿®æ”¹
**å¤šå¸§é…ç½®**ï¼šé€šè¿‡SequentialSendDialogçš„å®ä¾‹åˆ—è¡¨é…ç½®ï¼Œä½†æ²¡æœ‰æ•´ä½“é…ç½®çš„ä¿å­˜/åŠ è½½

## 2. å…³é”®é—®é¢˜é‡æ–°è¯†åˆ«

### 2.1 é…ç½®æŒä¹…åŒ–ç¼ºå¤±

- **å•å¸§å®šæ—¶/è§¦å‘é…ç½®**ï¼šç›®å‰åªåœ¨å†…å­˜ä¸­ï¼Œæ²¡æœ‰æŒä¹…åŒ–æœºåˆ¶
- **å¤šå¸§ç­–ç•¥é…ç½®**ï¼šé¡ºåºå‘é€çš„é…ç½®æ— æ³•ä¿å­˜ä¸ºæ¨¡æ¿
- **APIé€‰æ‹©æ··æ·†**ï¼šéœ€è¦åŒºåˆ†å®ä¾‹æ•°æ®å­˜å‚¨å’Œé…ç½®æ–‡ä»¶æ“ä½œ

### 2.2 ç•Œé¢å¤ç”¨åº¦ä½

- å®šæ—¶å’Œè§¦å‘çš„é…ç½®UIåˆ†æ•£åœ¨å„è‡ªå¯¹è¯æ¡†ä¸­
- ç¼ºå°‘ç‹¬ç«‹çš„é…ç½®ç»„ä»¶ï¼Œéš¾ä»¥å¤ç”¨

### 2.3 æ¥å£è®¾è®¡é—®é¢˜

- ç°æœ‰æ–‡ä»¶æ“ä½œä¸æ‰©å±•éœ€æ±‚å­˜åœ¨æ¥å£ä¸åŒ¹é…
- ç±»å‹å®šä¹‰ä¸ç°æœ‰ç³»ç»Ÿä¸ä¸€è‡´

## 3. ä¿®æ­£åçš„ç²¾ç¡®æ–¹æ¡ˆ

### 3.1 é‡æ–°è®¾è®¡é…ç½®ä¿å­˜æœºåˆ¶

#### 3.1.1 åˆ›å»ºä¸“é—¨çš„ä»»åŠ¡é…ç½®ç®¡ç†å™¨

**æ–°æ–‡ä»¶**: `src/composables/frames/sendFrame/useTaskConfigManager.ts`

```typescript
import { filesAPI } from '../../../utils/electronApi';
import type { SendFrameInstance } from '../../../types/frames/sendInstances';
import type { TimedTaskConfig, TriggerTaskConfig } from '../../../stores/frames/sendTasksStore';

// ä»»åŠ¡é…ç½®æ–‡ä»¶æ ¼å¼
interface TaskConfigFile {
  version: string;
  configType:
    | 'single-immediate'
    | 'single-timed'
    | 'single-triggered'
    | 'multi-immediate'
    | 'multi-timed'
    | 'multi-triggered';
  name: string;
  description?: string;
  // å®ä¾‹æ•°æ®
  instances: SendFrameInstance[];
  // ç›®æ ‡é…ç½®ï¼ˆå®ä¾‹åˆ°ç›®æ ‡çš„æ˜ å°„ï¼‰
  targets: { instanceId: string; targetId: string; interval?: number }[];
  // ç­–ç•¥é…ç½®
  strategy?: {
    type: 'timed' | 'triggered';
    config: TimedTaskConfig | TriggerTaskConfig;
  };
  createdAt: string;
  updatedAt: string;
}

export function useTaskConfigManager() {
  // ä¿å­˜ä»»åŠ¡é…ç½®åˆ°ç”¨æˆ·é€‰æ‹©çš„æ–‡ä»¶
  async function saveTaskConfig(
    instances: SendFrameInstance[],
    targets: { instanceId: string; targetId: string; interval?: number }[],
    strategy?: { type: 'timed' | 'triggered'; config: any },
    name: string = 'ä»»åŠ¡é…ç½®',
    description?: string,
  ): Promise<{ success: boolean; filePath?: string; message?: string }> {
    try {
      const configData: TaskConfigFile = {
        version: '1.0',
        configType:
          instances.length === 1
            ? `single-${strategy?.type || 'immediate'}`
            : `multi-${strategy?.type || 'immediate'}`,
        name,
        description,
        instances,
        targets,
        strategy,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      // ä½¿ç”¨ electron çš„æ–‡ä»¶å¯¹è¯æ¡†è®©ç”¨æˆ·é€‰æ‹©ä¿å­˜ä½ç½®
      const { dialog } = window.require('electron').remote;
      const result = await dialog.showSaveDialog({
        title: 'ä¿å­˜ä»»åŠ¡é…ç½®',
        defaultPath: `${name.replace(/\s+/g, '_')}.json`,
        filters: [{ name: 'JSON æ–‡ä»¶', extensions: ['json'] }],
      });

      if (result.canceled || !result.filePath) {
        return { success: false, message: 'ç”¨æˆ·å–æ¶ˆä¿å­˜' };
      }

      // ä½¿ç”¨ filesAPI ä¿å­˜åˆ°ç”¨æˆ·é€‰æ‹©çš„è·¯å¾„
      return await filesAPI.saveJsonToFile(result.filePath, configData);
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : 'ä¿å­˜å¤±è´¥',
      };
    }
  }

  // ä»ç”¨æˆ·é€‰æ‹©çš„æ–‡ä»¶åŠ è½½ä»»åŠ¡é…ç½®
  async function loadTaskConfig(): Promise<{
    success: boolean;
    data?: {
      instances: SendFrameInstance[];
      targets: { instanceId: string; targetId: string; interval?: number }[];
      strategy?: { type: 'timed' | 'triggered'; config: any };
      name: string;
      description?: string;
    };
    message?: string;
  }> {
    try {
      // ä½¿ç”¨ electron çš„æ–‡ä»¶å¯¹è¯æ¡†è®©ç”¨æˆ·é€‰æ‹©æ–‡ä»¶
      const { dialog } = window.require('electron').remote;
      const result = await dialog.showOpenDialog({
        title: 'åŠ è½½ä»»åŠ¡é…ç½®',
        filters: [{ name: 'JSON æ–‡ä»¶', extensions: ['json'] }],
        properties: ['openFile'],
      });

      if (result.canceled || !result.filePaths?.length) {
        return { success: false, message: 'ç”¨æˆ·å–æ¶ˆåŠ è½½' };
      }

      // ä½¿ç”¨ filesAPI åŠ è½½æ–‡ä»¶
      const loadResult = await filesAPI.loadJsonFromFile(result.filePaths[0]);

      if (!loadResult.success) {
        return loadResult;
      }

      const configData = loadResult.data as TaskConfigFile;

      // éªŒè¯é…ç½®æ ¼å¼
      if (!configData.version || !configData.instances || !configData.targets) {
        return { success: false, message: 'æ— æ•ˆçš„é…ç½®æ–‡ä»¶æ ¼å¼' };
      }

      return {
        success: true,
        data: {
          instances: configData.instances,
          targets: configData.targets,
          strategy: configData.strategy,
          name: configData.name,
          description: configData.description,
        },
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : 'åŠ è½½å¤±è´¥',
      };
    }
  }

  return {
    saveTaskConfig,
    loadTaskConfig,
  };
}
```

#### 3.1.2 ä¿®æ­£ç°æœ‰Composableçš„æ–‡ä»¶æ“ä½œ

**ä¿®æ”¹æ–‡ä»¶**: `src/composables/frames/sendFrame/sendFrameInsComposable.ts`

**åœ¨useInstancesImportExportä¸­æ·»åŠ æ–°æ–¹æ³•**ï¼š

```typescript
// ... existing code ...

/**
 * å¸§å®ä¾‹å¯¼å…¥å¯¼å‡ºåŠŸèƒ½
 */
export function useInstancesImportExport(state: ReturnType<typeof useInstancesState>) {
  // ... existing code ...

  // æ–°å¢ï¼šä½¿ç”¨ç”¨æˆ·é€‰æ‹©çš„è·¯å¾„ä¿å­˜é…ç½®
  async function saveConfigToUserFile(
    instances: SendFrameInstance[],
    targets: { instanceId: string; targetId: string; interval?: number }[],
    strategy?: { type: 'timed' | 'triggered'; config: any },
    name: string = 'å‘é€é…ç½®',
  ): Promise<boolean | null> {
    return state.withErrorHandling(async () => {
      const { saveTaskConfig } = useTaskConfigManager();
      const result = await saveTaskConfig(instances, targets, strategy, name);
      return result.success;
    }, 'ä¿å­˜é…ç½®åˆ°æ–‡ä»¶å¤±è´¥');
  }

  // æ–°å¢ï¼šä»ç”¨æˆ·é€‰æ‹©çš„æ–‡ä»¶åŠ è½½é…ç½®
  async function loadConfigFromUserFile(): Promise<{
    instances: SendFrameInstance[];
    targets: { instanceId: string; targetId: string; interval?: number }[];
    strategy?: { type: 'timed' | 'triggered'; config: any };
    name: string;
  } | null> {
    return state.withErrorHandling(async () => {
      const { loadTaskConfig } = useTaskConfigManager();
      const result = await loadTaskConfig();

      if (!result.success || !result.data) {
        throw new Error(result.message || 'åŠ è½½é…ç½®å¤±è´¥');
      }

      return result.data;
    }, 'ä»æ–‡ä»¶åŠ è½½é…ç½®å¤±è´¥');
  }

  return {
    exportToJSON,
    importFromJSON,
    saveToFile, // ä¿ç•™åŸæœ‰çš„å®ä¾‹æ•°æ®å¯¼å‡ºåŠŸèƒ½
    loadFromFile, // ä¿ç•™åŸæœ‰çš„å®ä¾‹æ•°æ®å¯¼å…¥åŠŸèƒ½
    saveConfigToUserFile, // æ–°å¢ï¼šé…ç½®æ–‡ä»¶ä¿å­˜
    loadConfigFromUserFile, // æ–°å¢ï¼šé…ç½®æ–‡ä»¶åŠ è½½
  };
}
```

### 3.2 ä¿®æ­£ç±»å‹å®šä¹‰

#### 3.2.1 æ‰©å±•ç°æœ‰ç±»å‹å®šä¹‰

**ä¿®æ”¹æ–‡ä»¶**: `src/types/frames/sendInstances.ts`

**åœ¨æ–‡ä»¶æœ«å°¾æ·»åŠ **ï¼š

```typescript
// ... existing code ...

/**
 * ä»»åŠ¡ç›®æ ‡é…ç½®
 * æè¿°å®ä¾‹åˆ°å‘é€ç›®æ ‡çš„æ˜ å°„å…³ç³»
 */
export interface InstanceTargetConfig {
  instanceId: string; // å®ä¾‹ID
  targetId: string; // å‘é€ç›®æ ‡IDï¼ˆä¸²å£è·¯å¾„ç­‰ï¼‰
  interval?: number; // å‘é€é—´éš”ï¼ˆç”¨äºé¡ºåºå‘é€ï¼‰
}

/**
 * ç­–ç•¥é…ç½®åŸºç¡€æ¥å£
 */
export interface StrategyConfigBase {
  type: 'timed' | 'triggered';
}

/**
 * å®šæ—¶ç­–ç•¥é…ç½®
 */
export interface TimedStrategyConfig extends StrategyConfigBase {
  type: 'timed';
  sendInterval: number; // å‘é€é—´éš”ï¼ˆæ¯«ç§’ï¼‰
  repeatCount: number; // é‡å¤æ¬¡æ•°ï¼ˆ0è¡¨ç¤ºæ— é™ï¼‰
  isInfinite: boolean; // æ˜¯å¦æ— é™å¾ªç¯
  startDelay?: number; // å¼€å§‹å»¶æ—¶
}

/**
 * è§¦å‘ç­–ç•¥é…ç½®
 */
export interface TriggerStrategyConfig extends StrategyConfigBase {
  type: 'triggered';
  sourceId: string; // ç›‘å¬æ¥æºID
  triggerFrameId: string; // è§¦å‘å¸§ID
  conditions: TriggerCondition[]; // è§¦å‘æ¡ä»¶åˆ—è¡¨
  responseDelay?: number; // å“åº”å»¶æ—¶
}

/**
 * è§¦å‘æ¡ä»¶
 */
export interface TriggerCondition {
  id: string;
  fieldId: string;
  condition: 'equals' | 'not_equals' | 'greater' | 'less' | 'contains';
  value: string;
  logicOperator?: 'and' | 'or';
}

/**
 * å®Œæ•´çš„ä»»åŠ¡é…ç½®
 * åŒ…å«å®ä¾‹ã€ç›®æ ‡æ˜ å°„å’Œç­–ç•¥é…ç½®
 */
export interface CompleteTaskConfig {
  name: string;
  description?: string;
  instances: SendFrameInstance[];
  targets: InstanceTargetConfig[];
  strategy?: TimedStrategyConfig | TriggerStrategyConfig;
}
```

### 3.3 ä¿®æ­£ç•Œé¢é›†æˆæ–¹æ¡ˆ

#### 3.3.1 åˆ›å»ºå¢å¼ºç‰ˆé¡ºåºå‘é€å¯¹è¯æ¡†

**æ–°æ–‡ä»¶**: `src/components/frames/FrameSend/EnhancedSequentialSendDialog.vue`

```vue
<template>
  <q-dialog v-model="show" persistent class="enhanced-sequential-dialog">
    <q-card class="config-card bg-industrial-panel border-industrial">
      <q-card-section>
        <div class="text-h6 text-industrial-primary">å¤šå¸§å‘é€é…ç½®</div>
      </q-card-section>

      <!-- ç­–ç•¥é€‰æ‹©åŒºåŸŸ -->
      <q-card-section>
        <div class="text-subtitle1 text-industrial-primary mb-2">å‘é€ç­–ç•¥</div>
        <q-option-group v-model="sendStrategy" :options="strategyOptions" inline color="primary" />

        <!-- ç­–ç•¥é…ç½®æŒ‰é’® -->
        <q-btn
          v-if="sendStrategy !== 'immediate'"
          size="sm"
          color="accent"
          class="ml-2"
          @click="openStrategyConfig"
        >
          é…ç½®{{ strategyLabels[sendStrategy] }}å‚æ•°
        </q-btn>
      </q-card-section>

      <!-- å®ä¾‹ç®¡ç†åŒºåŸŸ - å¤ç”¨ç°æœ‰ç»„ä»¶ -->
      <q-card-section>
        <InstanceListManager
          v-model:instances="instancesInTask"
          @update:instances="onInstancesUpdate"
        />
      </q-card-section>

      <!-- é…ç½®æ–‡ä»¶æ“ä½œåŒºåŸŸ -->
      <q-card-section>
        <q-separator class="mb-3" />
        <div class="flex gap-2">
          <q-btn size="sm" color="primary" icon="save" @click="saveCurrentConfig"> ä¿å­˜é…ç½® </q-btn>
          <q-btn size="sm" color="secondary" icon="folder_open" @click="loadSavedConfig">
            åŠ è½½é…ç½®
          </q-btn>
        </div>
      </q-card-section>

      <!-- æŒ‰é’®åŒºåŸŸ -->
      <q-card-actions align="right">
        <q-btn label="å–æ¶ˆ" @click="cancel" />
        <q-btn
          label="å¼€å§‹å‘é€"
          color="primary"
          @click="confirm"
          :disable="!instancesInTask.length"
        />
      </q-card-actions>
    </q-card>

    <!-- ç‹¬ç«‹çš„ç­–ç•¥é…ç½®å¯¹è¯æ¡† -->
    <TimedConfigDialog
      v-if="sendStrategy === 'timed'"
      v-model="showTimedConfig"
      :initial-config="timedConfig"
      @confirm="onTimedConfigConfirm"
      @cancel="showTimedConfig = false"
    />

    <TriggerConfigDialog
      v-if="sendStrategy === 'triggered'"
      v-model="showTriggerConfig"
      :initial-config="triggerConfig"
      @confirm="onTriggerConfigConfirm"
      @cancel="showTriggerConfig = false"
    />
  </q-dialog>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import type { FrameInstanceInTask } from '../../../stores/frames/sendTasksStore';
import type { TimedStrategyConfig, TriggerStrategyConfig } from '../../../types/frames/sendInstances';
import { useInstancesImportExport } from '../../../composables/frames/sendFrame/sendFrameInsComposable';
import { useSendTaskManager } from '../../../composables/frames/sendFrame/useSendTaskManager';
import InstanceListManager from './InstanceListManager.vue';
import TimedConfigDialog from './TimedConfigDialog.vue';
import TriggerConfigDialog from './TriggerConfigDialog.vue';

const props = defineProps<{
  modelValue: boolean;
}>();

const emit = defineEmits<{
  'update:modelValue': [value: boolean];
  'confirm': [config: {
    instances: FrameInstanceInTask[];
    strategy: 'immediate' | 'timed' | 'triggered';
    strategyConfig?: TimedStrategyConfig | TriggerStrategyConfig;
  }];
}>();

// çŠ¶æ€ç®¡ç†
const show = computed({
  get: () => props.modelValue,
  set: (value) => emit('update:modelValue', value)
});

const sendStrategy = ref<'immediate' | 'timed' | 'triggered'>('immediate');
const instancesInTask = ref<FrameInstanceInTask[]>([]);
const showTimedConfig = ref(false);
const showTriggerConfig = ref(false);
const timedConfig = ref<TimedStrategyConfig | null>(null);
const triggerConfig = ref<TriggerStrategyConfig | null>(null);

// ç­–ç•¥é€‰é¡¹
const strategyOptions = [
  { label: 'ç«‹å³å‘é€', value: 'immediate' },
  { label: 'å®šæ—¶å‘é€', value: 'timed' },
  { label: 'è§¦å‘å‘é€', value: 'triggered' },
];

const strategyLabels = {
  immediate: 'ç«‹å³',
  timed: 'å®šæ—¶',
  triggered: 'è§¦å‘',
};

// ç»„åˆå¼å‡½æ•°
const { saveConfigToUserFile, loadConfigFromUserFile } = useInstancesImportExport(/* state */);
const { createTimedMultipleTask, createTriggeredMultipleTask, createSequentialTask } = useSendTaskManager();

// æ–¹æ³•
function openStrategyConfig() {
  if (sendStrategy.value === 'timed') {
    showTimedConfig.value = true;
  } else if (sendStrategy.value === 'triggered') {
    showTriggerConfig.value = true;
  }
}

function onInstancesUpdate(instances: FrameInstanceInTask[]) {
  instancesInTask.value = instances;
}

function onTimedConfigConfirm(config: TimedStrategyConfig) {
  timedConfig.value = config;
  showTimedConfig.value = false;
}

function onTriggerConfigConfirm(config: TriggerStrategyConfig) {
  triggerConfig.value = config;
  showTriggerConfig.value = false;
}

async function saveCurrentConfig() {
  if (!instancesInTask.value.length) {
    return;
  }

  // æ„å»ºå®Œæ•´é…ç½®
  const instances = instancesInTask.value.map(item =>
    /* ä»storeä¸­è·å–å®Œæ•´çš„SendFrameInstance */
  );

  const targets = instancesInTask.value.map(item => ({
    instanceId: item.instanceId,
    targetId: item.targetId,
    interval: item.interval,
  }));

  const strategy = sendStrategy.value === 'immediate' ? undefined : {
    type: sendStrategy.value,
    config: sendStrategy.value === 'timed' ? timedConfig.value : triggerConfig.value,
  };

  const result = await saveConfigToUserFile(instances, targets, strategy, 'å¤šå¸§å‘é€é…ç½®');

  if (result) {
    // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
  }
}

async function loadSavedConfig() {
  const result = await loadConfigFromUserFile();

  if (result) {
    // æ¢å¤é…ç½®
    instancesInTask.value = result.targets.map(target => ({
      id: `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      instanceId: target.instanceId,
      targetId: target.targetId,
      interval: target.interval,
    }));

    if (result.strategy) {
      sendStrategy.value = result.strategy.type;
      if (result.strategy.type === 'timed') {
        timedConfig.value = result.strategy.config as TimedStrategyConfig;
      } else if (result.strategy.type === 'triggered') {
        triggerConfig.value = result.strategy.config as TriggerStrategyConfig;
      }
    } else {
      sendStrategy.value = 'immediate';
    }
  }
}

function confirm() {
  let strategyConfig: TimedStrategyConfig | TriggerStrategyConfig | undefined;

  if (sendStrategy.value === 'timed') {
    strategyConfig = timedConfig.value || undefined;
  } else if (sendStrategy.value === 'triggered') {
    strategyConfig = triggerConfig.value || undefined;
  }

  emit('confirm', {
    instances: instancesInTask.value,
    strategy: sendStrategy.value,
    strategyConfig,
  });

  show.value = false;
}

function cancel() {
  show.value = false;
}
</script>
```

#### 3.3.2 ä¿®æ­£å•å¸§å‘é€é…ç½®ä¿å­˜

**ä¿®æ”¹æ–‡ä»¶**: `src/components/frames/FrameSend/TimedSendDialog.vue`

**åœ¨ç°æœ‰UIä¸‹æ–¹æ·»åŠ **ï¼š

```vue
<!-- ... existing code ... -->

<!-- é…ç½®ä¿å­˜/åŠ è½½åŒºåŸŸ -->
<q-separator class="my-3" />
<q-card-actions>
  <q-btn size="sm" @click="saveCurrentConfig" icon="save" color="primary">
    ä¿å­˜é…ç½®
  </q-btn>
  <q-btn size="sm" @click="loadSavedConfig" icon="folder_open" color="secondary">
    åŠ è½½é…ç½®
  </q-btn>
</q-card-actions>

<!-- ... existing code ... -->
```

**åœ¨scriptä¸­æ·»åŠ æ–¹æ³•**ï¼š

```typescript
// ... existing code ...

import { useInstancesImportExport } from '../../../composables/frames/sendFrame/sendFrameInsComposable';

// ... existing code ...

const { saveConfigToUserFile, loadConfigFromUserFile } = useInstancesImportExport(/* state */);

async function saveCurrentConfig() {
  if (!currentInstance.value) return;

  // æ„å»ºå•å®ä¾‹é…ç½®
  const instances = [currentInstance.value];
  const targets = [
    {
      instanceId: currentInstance.value.id,
      targetId: selectedTargetId.value, // å½“å‰é€‰æ‹©çš„ç›®æ ‡
      interval: 0,
    },
  ];

  const strategy = {
    type: 'timed' as const,
    config: {
      type: 'timed' as const,
      sendInterval: timedConfig.value.interval,
      repeatCount: timedConfig.value.repeatCount,
      isInfinite: timedConfig.value.isInfinite,
      startDelay: timedConfig.value.startDelay,
    } as TimedStrategyConfig,
  };

  const result = await saveConfigToUserFile(
    instances,
    targets,
    strategy,
    `å®šæ—¶å‘é€-${currentInstance.value.label}`,
  );

  if (result) {
    // æ˜¾ç¤ºä¿å­˜æˆåŠŸæ¶ˆæ¯
  }
}

async function loadSavedConfig() {
  const result = await loadConfigFromUserFile();

  if (result && result.instances.length && result.strategy?.type === 'timed') {
    // æ¢å¤é…ç½®
    const loadedInstance = result.instances[0];
    const loadedTarget = result.targets[0];
    const loadedStrategy = result.strategy.config as TimedStrategyConfig;

    // åº”ç”¨åˆ°å½“å‰é…ç½®
    timedConfig.value = {
      interval: loadedStrategy.sendInterval,
      repeatCount: loadedStrategy.repeatCount,
      isInfinite: loadedStrategy.isInfinite,
      startDelay: loadedStrategy.startDelay || 0,
    };

    // å¦‚æœéœ€è¦ï¼Œä¹Ÿå¯ä»¥åˆ‡æ¢åˆ°åŠ è½½çš„å®ä¾‹
    // setCurrentInstance(loadedInstance.id);
  }
}
```

### 3.4 ä¿®æ­£ä»»åŠ¡ç®¡ç†å™¨é›†æˆ

#### 3.4.1 ä¿®æ­£ä»»åŠ¡ç®¡ç†å™¨çš„ä½¿ç”¨æ–¹å¼

**ä¿®æ”¹æ–‡ä»¶**: `src/composables/frames/sendFrame/useSendTaskManager.ts`

**åœ¨æ–‡ä»¶æœ«å°¾æ·»åŠ ä¾¿æ·æ–¹æ³•**ï¼š

```typescript
// ... existing code ...

  /**
   * ä¾¿æ·æ–¹æ³•ï¼šæ ¹æ®é…ç½®åˆ›å»ºå¹¶å¯åŠ¨ä»»åŠ¡
   */
  async function createAndStartTaskFromConfig(
    instances: FrameInstanceInTask[],
    strategy: 'immediate' | 'timed' | 'triggered',
    strategyConfig?: TimedStrategyConfig | TriggerStrategyConfig,
    name: string = 'å‘é€ä»»åŠ¡'
  ): Promise<string | null> {
    let taskId: string | null = null;

    // æ ¹æ®ç­–ç•¥åˆ›å»ºå¯¹åº”çš„ä»»åŠ¡
    switch (strategy) {
      case 'immediate':
        if (instances.length === 1) {
          // å•å®ä¾‹ç«‹å³å‘é€ - ç›´æ¥å‘é€ï¼Œä¸åˆ›å»ºä»»åŠ¡
          const instance = sendFrameInstancesStore.instances.find(
            i => i.id === instances[0].instanceId
          );
          if (instance) {
            await serialStore.sendFrameInstance(instances[0].targetId, instance);
          }
          return null;
        } else {
          // å¤šå®ä¾‹é¡ºåºå‘é€
          taskId = createSequentialTask(instances, name);
        }
        break;

      case 'timed':
        if (!strategyConfig || strategyConfig.type !== 'timed') {
          processingError.value = 'å®šæ—¶å‘é€éœ€è¦æä¾›å®šæ—¶é…ç½®';
          return null;
        }

        const timedConfig = strategyConfig as TimedStrategyConfig;

        if (instances.length === 1) {
          taskId = createTimedSingleTask(
            instances[0].instanceId,
            instances[0].targetId,
            timedConfig.sendInterval,
            timedConfig.repeatCount,
            timedConfig.isInfinite,
            name
          );
        } else {
          taskId = createTimedMultipleTask(
            instances,
            timedConfig.sendInterval,
            timedConfig.repeatCount,
            timedConfig.isInfinite,
            name
          );
        }
        break;

      case 'triggered':
        if (!strategyConfig || strategyConfig.type !== 'triggered') {
          processingError.value = 'è§¦å‘å‘é€éœ€è¦æä¾›è§¦å‘é…ç½®';
          return null;
        }

        const triggerConfig = strategyConfig as TriggerStrategyConfig;

        if (instances.length === 1) {
          taskId = createTriggeredSingleTask(
            instances[0].instanceId,
            instances[0].targetId,
            triggerConfig.sourceId,
            triggerConfig.triggerFrameId,
            triggerConfig.conditions,
            name
          );
        } else {
          taskId = createTriggeredMultipleTask(
            instances,
            triggerConfig.sourceId,
            triggerConfig.triggerFrameId,
            triggerConfig.conditions,
            name
          );
        }
        break;
    }

    // å¦‚æœåˆ›å»ºäº†ä»»åŠ¡ï¼Œç«‹å³å¯åŠ¨
    if (taskId) {
      const success = await startTask(taskId);
      if (!success) {
        // å¯åŠ¨å¤±è´¥ï¼Œç§»é™¤ä»»åŠ¡
        sendTasksStore.removeTask(taskId);
        return null;
      }
    }

    return taskId;
  }

  return {
    // çŠ¶æ€
    currentTaskId,
    currentTask,
    activeTasks,
    isProcessing,
    processingError,

    // ä»»åŠ¡åˆ›å»º
    createSequentialTask,
    createTimedSingleTask,
    createTimedMultipleTask,
    createTriggeredSingleTask,
    createTriggeredMultipleTask,

    // ä»»åŠ¡æ§åˆ¶
    startTask,
    stopTask,
    pauseTask,
    resumeTask,

    // é…ç½®ç®¡ç†
    saveTaskConfigToFile,
    loadTaskConfigFromFile,

    // ä¾¿æ·æ–¹æ³•
    createAndStartTaskFromConfig,
  };
}
```

## 4. å®æ–½æ­¥éª¤ï¼ˆä¿®æ­£åï¼‰

### 4.1 ç¬¬ä¸€é˜¶æ®µï¼šä¿®æ­£é…ç½®æ ¼å¼å’ŒAPI

1. **åˆ›å»ºä»»åŠ¡é…ç½®ç®¡ç†å™¨**ï¼š

   - å®ç° `useTaskConfigManager` ç»„åˆå¼å‡½æ•°
   - ä½¿ç”¨ `filesAPI` è¿›è¡Œç”¨æˆ·æ–‡ä»¶æ“ä½œ
   - å®šä¹‰å®Œæ•´çš„é…ç½®æ–‡ä»¶æ ¼å¼

2. **æ‰©å±•ç±»å‹å®šä¹‰**ï¼š

   - æ·»åŠ ç­–ç•¥é…ç½®ç›¸å…³ç±»å‹
   - ç¡®ä¿ä¸ç°æœ‰ç±»å‹çš„å…¼å®¹æ€§

3. **ä¿®æ­£ç°æœ‰Composable**ï¼š
   - åœ¨ `useInstancesImportExport` ä¸­æ·»åŠ é…ç½®æ–‡ä»¶æ“ä½œæ–¹æ³•
   - ä¿æŒç°æœ‰å®ä¾‹æ•°æ®æ“ä½œçš„ç¨³å®šæ€§

### 4.2 ç¬¬äºŒé˜¶æ®µï¼šåˆ›å»ºç‹¬ç«‹é…ç½®å¯¹è¯æ¡†

1. **å®šæ—¶é…ç½®å¯¹è¯æ¡†**ï¼š

   - åˆ›å»º `TimedConfigDialog.vue`
   - æ”¯æŒå®Œæ•´çš„å®šæ—¶å‚æ•°é…ç½®

2. **è§¦å‘é…ç½®å¯¹è¯æ¡†**ï¼š
   - åˆ›å»º `TriggerConfigDialog.vue`
   - æ”¯æŒæ¡ä»¶é…ç½®å’Œç›‘å¬è®¾ç½®

### 4.3 ç¬¬ä¸‰é˜¶æ®µï¼šæ‰©å±•å¤šå¸§æ”¯æŒ

1. **åˆ›å»ºå¢å¼ºç‰ˆå¯¹è¯æ¡†**ï¼š

   - å®ç° `EnhancedSequentialSendDialog.vue`
   - é›†æˆç­–ç•¥é€‰æ‹©å’Œé…ç½®ä¿å­˜åŠŸèƒ½
   - å¤ç”¨ç°æœ‰çš„ `InstanceListManager`

2. **ä¿®æ­£ä»»åŠ¡ç®¡ç†å™¨é›†æˆ**ï¼š
   - æ·»åŠ ä¾¿æ·çš„ä»»åŠ¡åˆ›å»ºå’Œå¯åŠ¨æ–¹æ³•
   - ç¡®ä¿ä¸ç°æœ‰ä»»åŠ¡ç³»ç»Ÿçš„æ— ç¼é›†æˆ

### 4.4 ç¬¬å››é˜¶æ®µï¼šå®Œå–„å•å¸§é…ç½®

1. **æ‰©å±•å•å¸§å‘é€å¯¹è¯æ¡†**ï¼š

   - åœ¨ç°æœ‰å¯¹è¯æ¡†ä¸­æ·»åŠ é…ç½®ä¿å­˜åŠŸèƒ½
   - ä¿æŒç•Œé¢ç®€æ´æ€§

2. **æµ‹è¯•å’Œä¼˜åŒ–**ï¼š
   - éªŒè¯æ‰€æœ‰é…ç½®çš„ä¿å­˜å’ŒåŠ è½½
   - ç¡®ä¿å‘åå…¼å®¹æ€§

## 5. å…³é”®æŠ€æœ¯å†³ç­–ï¼ˆä¿®æ­£åï¼‰

### 5.1 APIé€‰æ‹©ç­–ç•¥

- **å®ä¾‹æ•°æ®ç®¡ç†**ï¼šç»§ç»­ä½¿ç”¨ `dataStorageAPI.sendInstances`
- **é…ç½®æ–‡ä»¶æ“ä½œ**ï¼šä½¿ç”¨ `filesAPI` è¿›è¡Œç”¨æˆ·é€‰æ‹©è·¯å¾„çš„æ–‡ä»¶æ“ä½œ
- **ä»»åŠ¡ç®¡ç†**ï¼šç»§ç»­ä½¿ç”¨ç°æœ‰çš„ `useSendTaskManager`

### 5.2 æ•°æ®åˆ†ç¦»ç­–ç•¥

- **å®ä¾‹æ•°æ®**ï¼šé€šè¿‡ç°æœ‰çš„å®ä¾‹ç®¡ç†ç³»ç»Ÿ
- **ç›®æ ‡æ˜ å°„**ï¼šå®ä¾‹åˆ°å‘é€ç›®æ ‡çš„æ˜ å°„å…³ç³»
- **ç­–ç•¥é…ç½®**ï¼šå®šæ—¶/è§¦å‘çš„å‚æ•°é…ç½®
- **é…ç½®æ–‡ä»¶**ï¼šåŒ…å«ä»¥ä¸Šä¸‰éƒ¨åˆ†çš„å®Œæ•´é…ç½®

### 5.3 ç•Œé¢é›†æˆç­–ç•¥

- **ä¸ç ´åç°æœ‰ç»„ä»¶**ï¼šåˆ›å»ºæ–°çš„åŒ…è£…ç»„ä»¶
- **å¤ç”¨ç°æœ‰é€»è¾‘**ï¼šæœ€å¤§åŒ–åˆ©ç”¨ç°æœ‰çš„ç®¡ç†å™¨å’ŒçŠ¶æ€
- **æ¸è¿›å¼æ‰©å±•**ï¼šå¯ä»¥ç‹¬ç«‹ä½¿ç”¨æ¯ä¸ªåŠŸèƒ½æ¨¡å—

## 6. éªŒæ”¶æ ‡å‡†ï¼ˆä¿®æ­£åï¼‰

### 6.1 åŠŸèƒ½éªŒæ”¶

- âœ… å•å¸§å‘é€æ”¯æŒå®šæ—¶å’Œè§¦å‘é…ç½®çš„ä¿å­˜/åŠ è½½
- âœ… å¤šå¸§å‘é€æ”¯æŒç­–ç•¥é€‰æ‹©å’Œé…ç½®ä¿å­˜/åŠ è½½
- âœ… é…ç½®æ–‡ä»¶å¯ä»¥è·¨ç­–ç•¥å¤ç”¨
- âœ… ä¸ç°æœ‰ä»»åŠ¡ç®¡ç†ç³»ç»Ÿæ— ç¼é›†æˆ

### 6.2 ä»£ç è´¨é‡

- âœ… æœ€å¤§åŒ–å¤ç”¨ç°æœ‰ç»„ä»¶å’Œé€»è¾‘
- âœ… æ¥å£è®¾è®¡ä¸ç°æœ‰ç³»ç»Ÿä¸€è‡´
- âœ… ä¿æŒç°æœ‰ç»„ä»¶çš„æ¥å£ç¨³å®šæ€§
- âœ… æ­£ç¡®åŒºåˆ†ä¸åŒAPIçš„ä½¿ç”¨åœºæ™¯

### 6.3 æ¥å£ä¸€è‡´æ€§

- âœ… æ–‡ä»¶æ“ä½œä½¿ç”¨æ­£ç¡®çš„APIï¼ˆfilesAPI vs dataStorageAPIï¼‰
- âœ… ç±»å‹å®šä¹‰ä¸ç°æœ‰ç³»ç»Ÿå…¼å®¹
- âœ… ä»»åŠ¡ç®¡ç†å™¨è°ƒç”¨æ–¹å¼æ­£ç¡®
- âœ… é…ç½®æ•°æ®æ ¼å¼ç»Ÿä¸€ä¸”å¯æ‰©å±•

è¿™ä¸ªä¿®æ­£åçš„æ–¹æ¡ˆè§£å†³äº†åŸè®¾è®¡ä¸­çš„æ¥å£å¯¹æ¥é—®é¢˜ï¼Œç¡®ä¿äº†ä¸ç°æœ‰ç³»ç»Ÿçš„å®Œå…¨å…¼å®¹æ€§ã€‚
