# 发送任务系统重构计划

## 问题分析

### 当前主要问题

1. **代码重复严重**: 单帧和多帧发送逻辑几乎相同，却分为不同函数
2. **配置逻辑混乱**: 定时发送配置没有正确应用，实例间延时被忽略
3. **类型系统冗余**: 任务类型过于细分（6种类型），增加维护成本
4. **目标路径解析不一致**: 顺序发送有targetPath解析，定时/触发发送缺失
5. **状态管理复杂**: 多个Store之间职责不清，数据流混乱

### 设计目标

- 统一发送逻辑，减少代码重复
- 简化任务类型，优化配置结构
- 增强复用性和可维护性
- 统一目标路径处理机制
- 清晰的数据流和状态管理

## 重构方案

### 1. 任务类型简化

#### 新的任务类型结构

```
- immediate: 立即发送（单次或序列）
- scheduled: 计划发送（定时或触发）
```

#### 执行模式

```
- single: 单帧发送
- sequence: 序列发送（多帧按顺序）
- parallel: 并发发送（多帧同时，可选）
```

#### 触发类型

```
- manual: 手动触发
- timed: 时间触发
- condition: 条件触发
```

### 2. 统一配置结构

#### 核心配置接口

```
TaskConfig {
  name: string
  description?: string
  instances: FrameInstanceConfig[]
  execution: ExecutionConfig
  trigger: TriggerConfig
}
```

#### 帧实例配置

```
FrameInstanceConfig {
  id: string
  instanceId: string
  targetId: string
  delay?: number  // 发送前延时
  repeat?: number // 重复次数（0=无限）
}
```

#### 执行配置

```
ExecutionConfig {
  mode: 'single' | 'sequence' | 'parallel'
  interval?: number     // 序列/重复间隔
  instanceDelay?: number // 实例间默认延时
  maxConcurrency?: number // 并发数限制
}
```

#### 触发配置

```
TriggerConfig {
  type: 'manual' | 'timed' | 'condition'
  timed?: {
    interval: number
    repeat: number
    infinite: boolean
    startDelay?: number
  }
  condition?: {
    sourceId: string
    frameId: string
    conditions: ConditionRule[]
  }
}
```

### 3. 发送逻辑统一

#### 核心发送引擎

- 单一的 `TaskExecutor` 类处理所有发送逻辑
- 根据配置动态调整执行策略
- 统一的目标路径解析和错误处理
- 可暂停/恢复的执行状态管理

#### 执行流程

1. **任务准备**: 验证配置、解析目标路径、初始化状态
2. **实例处理**: 根据模式（single/sequence/parallel）执行
3. **延时管理**: 统一处理各种延时逻辑
4. **状态更新**: 实时更新进度和状态
5. **错误处理**: 统一的错误捕获和恢复机制

### 4. Store重构

#### TaskStore简化

- 移除类型细分，使用统一的Task接口
- 简化状态管理，减少冗余字段
- 优化任务生命周期管理

#### InstanceStore优化

- 专注于实例CRUD操作
- 移除发送相关逻辑到TaskStore
- 简化状态结构

#### 新增ExecutorStore

- 专门管理任务执行器
- 处理并发执行限制
- 管理全局执行状态

### 5. UI组件重构

#### 组件简化

- 合并 `TimedSendDialog` 和 `SequentialSendDialog`
- 统一的 `TaskConfigDialog` 组件
- 可配置的策略面板组件

#### 配置向导

- 分步骤的任务创建向导
- 智能默认值和预设配置
- 实时配置验证和预览

#### 监控面板

- 统一的任务监控界面
- 实时进度和状态显示
- 批量操作支持

### 6. 工具函数重构

#### 配置管理

- 统一的配置序列化/反序列化
- 配置验证和迁移工具
- 预设配置管理

#### 目标路径处理

- 统一的目标解析器
- 连接状态监控
- 自动重连机制

#### 时间管理

- 统一的定时器管理器
- 高精度时间调度
- 资源清理机制

### 7. 类型系统优化

#### 核心类型简化

- 减少枚举类型数量
- 使用联合类型增强灵活性
- 强化类型安全性

#### 配置类型

- 使用条件类型优化配置接口
- 提供类型守卫函数
- 增强IDE支持

### 8. 错误处理改进

#### 统一错误类型

- 定义标准错误代码
- 分级错误处理策略
- 用户友好的错误信息

#### 恢复机制

- 自动重试逻辑
- 任务状态恢复
- 数据一致性保证

### 9. 性能优化

#### 内存管理

- 及时清理定时器和监听器
- 优化大量实例的处理
- 防止内存泄漏

#### 执行效率

- 减少不必要的状态更新
- 优化UI渲染性能
- 异步处理长时间操作

### 10. 迁移策略

#### 数据迁移

- 自动检测旧配置格式
- 提供配置迁移工具
- 保持数据完整性

#### 渐进式重构

- 优先重构核心逻辑
- 保持API兼容性过渡期
- 分阶段验证功能

## 实施计划

### 第一阶段：核心重构

1. 重构TaskStore和相关类型定义
2. 实现统一的TaskExecutor
3. 更新配置管理工具

### 第二阶段：UI重构

1. 重构主要对话框组件
2. 更新监控面板
3. 优化用户交互流程

### 第三阶段：优化完善

1. 性能优化和测试
2. 错误处理完善
3. 文档和示例更新

### 第四阶段：清理和维护

1. 移除废弃代码
2. 代码质量检查
3. 最终测试和发布

## 预期收益

- **代码量减少**: 预计减少40%的重复代码
- **维护成本降低**: 统一的逻辑结构便于维护
- **功能增强**: 更灵活的配置和更强的扩展性
- **用户体验**: 更简洁直观的操作界面
- **稳定性提升**: 统一的错误处理和状态管理
