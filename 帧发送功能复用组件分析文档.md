# å¸§å‘é€åŠŸèƒ½å¤ç”¨ç»„ä»¶åˆ†ææ–‡æ¡£

## 1. ç°æœ‰å¯å¤ç”¨èµ„æºåˆ†æ

### 1.1 ç±»å‹å®šä¹‰ï¼ˆå·²æœ‰ï¼‰

**æ–‡ä»¶ä½ç½®**: `src/types/frames/sendInstances.ts`

- âœ… `SendFrameInstance` - å‘é€å¸§å®ä¾‹åŸºç¡€ç±»å‹
- âœ… `SendInstanceField` - å‘é€å®ä¾‹å­—æ®µç±»å‹
- ğŸ”„ éœ€è¦æ‰©å±•ï¼šä»»åŠ¡é…ç½®ç›¸å…³ç±»å‹

**æ–‡ä»¶ä½ç½®**: `src/types/serial/serial.ts`

- âœ… `SerialPortOptions` - ä¸²å£é…ç½®é€‰é¡¹
- âœ… `SerialPortInfo` - ä¸²å£ä¿¡æ¯
- âœ… `ConnectionStatus` - è¿æ¥çŠ¶æ€
- ğŸ”„ éœ€è¦æ‰©å±•ï¼šå¤šç«¯å£ä»»åŠ¡ç®¡ç†ç›¸å…³ç±»å‹

**æ–‡ä»¶ä½ç½®**: `src/types/common/connectionTarget.ts`

- âœ… `ConnectionTarget` - è¿æ¥ç›®æ ‡æ¥å£
- âœ… `ConnectionType` - è¿æ¥ç±»å‹
- âœ… `ConnectionTargetStatus` - è¿æ¥çŠ¶æ€

### 1.2 å·¥å‚å‡½æ•°ï¼ˆå·²æœ‰ï¼‰

**æ–‡ä»¶ä½ç½®**: `src/types/frames/sendInstanceFactories.ts`

- âœ… `createSendInstanceField()` - åˆ›å»ºå‘é€å®ä¾‹å­—æ®µ
- âœ… `createSendFrameInstance()` - åˆ›å»ºå‘é€å¸§å®ä¾‹
- ğŸ”„ éœ€è¦æ‰©å±•ï¼šä»»åŠ¡é…ç½®å·¥å‚å‡½æ•°

### 1.3 å·¥å…·å‡½æ•°ï¼ˆå·²æœ‰ï¼‰

**æ–‡ä»¶ä½ç½®**: `src/utils/common/fileUtils.ts`

- âœ… `loadJsonData<T>()` - åŠ è½½JSONæ•°æ®
- âœ… `saveJsonData<T>()` - ä¿å­˜JSONæ•°æ®
- âœ… `ensureDirectory()` - ç¡®ä¿ç›®å½•å­˜åœ¨
- âœ… `fileExists()` - æ£€æŸ¥æ–‡ä»¶å­˜åœ¨

**æ–‡ä»¶ä½ç½®**: `src/utils/common/ipcUtils.ts`

- âœ… `registerHandlers()` - æ³¨å†ŒIPCå¤„ç†å™¨
- âœ… `createResponseWrapper()` - åˆ›å»ºå“åº”åŒ…è£…å™¨
- âœ… `registerApiHandlers()` - æ³¨å†ŒAPIå¤„ç†å™¨

**æ–‡ä»¶ä½ç½®**: `src/utils/frames/frameInstancesUtils.ts`

- âœ… `withErrorHandling()` - é”™è¯¯å¤„ç†åŒ…è£…å™¨
- âœ… `calculateChecksum()` - è®¡ç®—æ ¡éªŒå’Œ
- âœ… `frameToBuffer()` - å¸§è½¬æ¢ä¸ºç¼“å†²åŒº
- âœ… `generateNextAvailableId()` - ç”Ÿæˆä¸‹ä¸€ä¸ªå¯ç”¨ID

## 2. æ–°å¢å¤ç”¨ç±»å‹å®šä¹‰

### 2.1 æ‰©å±•å‘é€å®ä¾‹ç±»å‹

**æ–‡ä»¶ä½ç½®**: `src/types/frames/sendInstances.ts`

```typescript
// æ–°å¢ï¼šä»»åŠ¡ç›®æ ‡é…ç½®
export interface InstanceTargetConfig {
  instanceId: string; // å®ä¾‹ID
  targetId: string; // å‘é€ç›®æ ‡IDï¼ˆä¸²å£è·¯å¾„ç­‰ï¼‰
  interval?: number; // å‘é€é—´éš”ï¼ˆç”¨äºé¡ºåºå‘é€ï¼‰
}

// æ–°å¢ï¼šå®šæ—¶ç­–ç•¥é…ç½®
export interface TimedStrategyConfig {
  type: 'timed';
  sendInterval: number; // å‘é€é—´éš”ï¼ˆæ¯«ç§’ï¼‰
  repeatCount: number; // é‡å¤æ¬¡æ•°ï¼ˆ0è¡¨ç¤ºæ— é™ï¼‰
  isInfinite: boolean; // æ˜¯å¦æ— é™å¾ªç¯
  startDelay?: number; // å¼€å§‹å»¶æ—¶
}

// æ–°å¢ï¼šè§¦å‘ç­–ç•¥é…ç½®
export interface TriggerStrategyConfig {
  type: 'triggered';
  sourceId: string; // ç›‘å¬æ¥æºID
  triggerFrameId: string; // è§¦å‘å¸§ID
  conditions: TriggerCondition[]; // è§¦å‘æ¡ä»¶åˆ—è¡¨
  responseDelay?: number; // å“åº”å»¶æ—¶
}

// æ–°å¢ï¼šè§¦å‘æ¡ä»¶
export interface TriggerCondition {
  id: string;
  fieldId: string;
  condition: 'equals' | 'not_equals' | 'greater' | 'less' | 'contains';
  value: string;
  logicOperator?: 'and' | 'or';
}

// æ–°å¢ï¼šç­–ç•¥é…ç½®è”åˆç±»å‹
export type StrategyConfig = TimedStrategyConfig | TriggerStrategyConfig;

// æ–°å¢ï¼šå®Œæ•´çš„ä»»åŠ¡é…ç½®
export interface CompleteTaskConfig {
  name: string;
  description?: string;
  instances: SendFrameInstance[];
  targets: InstanceTargetConfig[];
  strategy?: StrategyConfig;
}
```

### 2.2 æ–°å¢ä»»åŠ¡é…ç½®æ–‡ä»¶ç±»å‹

**æ–‡ä»¶ä½ç½®**: `src/types/frames/taskConfig.ts`

```typescript
import type { SendFrameInstance, InstanceTargetConfig, StrategyConfig } from './sendInstances';

// ä»»åŠ¡é…ç½®æ–‡ä»¶æ ¼å¼
export interface TaskConfigFile {
  version: string;
  configType:
    | 'single-immediate'
    | 'single-timed'
    | 'single-triggered'
    | 'multi-immediate'
    | 'multi-timed'
    | 'multi-triggered';
  name: string;
  description?: string;
  instances: SendFrameInstance[];
  targets: InstanceTargetConfig[];
  strategy?: StrategyConfig;
  createdAt: string;
  updatedAt: string;
}

// é…ç½®æ–‡ä»¶æ“ä½œç»“æœ
export interface ConfigFileResult<T = TaskConfigFile> {
  success: boolean;
  data?: T;
  message?: string;
  filePath?: string;
}
```

### 2.3 æ–°å¢ä»»åŠ¡çŠ¶æ€ç±»å‹

**æ–‡ä»¶ä½ç½®**: `src/types/frames/sendTasks.ts`

```typescript
import type { InstanceTargetConfig, StrategyConfig } from './sendInstances';

// ä»»åŠ¡çŠ¶æ€
export type TaskStatus = 'pending' | 'running' | 'paused' | 'completed' | 'error' | 'cancelled';

// ä»»åŠ¡ç±»å‹
export type TaskType = 'immediate' | 'timed' | 'triggered' | 'sequential';

// ä»»åŠ¡æ‰§è¡Œç»Ÿè®¡
export interface TaskExecutionStats {
  totalSent: number;
  successCount: number;
  errorCount: number;
  startTime?: Date;
  endTime?: Date;
  elapsedTime?: number;
}

// å‘é€ä»»åŠ¡æ¥å£
export interface SendTask {
  id: string;
  name: string;
  type: TaskType;
  status: TaskStatus;
  instances: InstanceTargetConfig[];
  strategy?: StrategyConfig;
  stats: TaskExecutionStats;
  createdAt: Date;
  updatedAt: Date;
  error?: string;
}
```

## 3. æ–°å¢å¤ç”¨å·¥å…·å‡½æ•°

### 3.1 ä»»åŠ¡é…ç½®ç®¡ç†å·¥å…·

**æ–‡ä»¶ä½ç½®**: `src/utils/frames/taskConfigUtils.ts`

```typescript
import type { TaskConfigFile, ConfigFileResult } from '../../types/frames/taskConfig';
import type {
  SendFrameInstance,
  InstanceTargetConfig,
  StrategyConfig,
} from '../../types/frames/sendInstances';

/**
 * åˆ›å»ºä»»åŠ¡é…ç½®æ–‡ä»¶æ•°æ®
 */
export function createTaskConfigFile(
  instances: SendFrameInstance[],
  targets: InstanceTargetConfig[],
  strategy?: StrategyConfig,
  name: string = 'ä»»åŠ¡é…ç½®',
  description?: string,
): TaskConfigFile {
  const configType =
    instances.length === 1
      ? `single-${strategy?.type || 'immediate'}`
      : `multi-${strategy?.type || 'immediate'}`;

  return {
    version: '1.0',
    configType: configType as TaskConfigFile['configType'],
    name,
    description,
    instances,
    targets,
    strategy,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };
}

/**
 * éªŒè¯ä»»åŠ¡é…ç½®æ–‡ä»¶æ ¼å¼
 */
export function validateTaskConfigFile(data: any): data is TaskConfigFile {
  return (
    data &&
    typeof data === 'object' &&
    data.version &&
    data.configType &&
    data.name &&
    Array.isArray(data.instances) &&
    Array.isArray(data.targets)
  );
}

/**
 * è·å–é…ç½®ç±»å‹çš„æ˜¾ç¤ºæ ‡ç­¾
 */
export function getConfigTypeLabel(configType: TaskConfigFile['configType']): string {
  const labels: Record<TaskConfigFile['configType'], string> = {
    'single-immediate': 'å•å¸§ç«‹å³å‘é€',
    'single-timed': 'å•å¸§å®šæ—¶å‘é€',
    'single-triggered': 'å•å¸§è§¦å‘å‘é€',
    'multi-immediate': 'å¤šå¸§é¡ºåºå‘é€',
    'multi-timed': 'å¤šå¸§å®šæ—¶å‘é€',
    'multi-triggered': 'å¤šå¸§è§¦å‘å‘é€',
  };
  return labels[configType] || 'æœªçŸ¥é…ç½®';
}
```

### 3.2 ç­–ç•¥é…ç½®éªŒè¯å·¥å…·

**æ–‡ä»¶ä½ç½®**: `src/utils/frames/strategyValidation.ts`

```typescript
import type {
  TimedStrategyConfig,
  TriggerStrategyConfig,
  StrategyConfig,
} from '../../types/frames/sendInstances';

// éªŒè¯ç»“æœæ¥å£
export interface ValidationResult {
  valid: boolean;
  errors: string[];
}

/**
 * éªŒè¯å®šæ—¶ç­–ç•¥é…ç½®
 */
export function validateTimedStrategy(config: TimedStrategyConfig): ValidationResult {
  const errors: string[] = [];

  if (!config.sendInterval || config.sendInterval <= 0) {
    errors.push('å‘é€é—´éš”å¿…é¡»å¤§äº0');
  }

  if (config.sendInterval < 100) {
    errors.push('å‘é€é—´éš”ä¸èƒ½å°äº100æ¯«ç§’');
  }

  if (!config.isInfinite && (!config.repeatCount || config.repeatCount <= 0)) {
    errors.push('éæ— é™å¾ªç¯æ—¶é‡å¤æ¬¡æ•°å¿…é¡»å¤§äº0');
  }

  if (config.startDelay && config.startDelay < 0) {
    errors.push('å¼€å§‹å»¶æ—¶ä¸èƒ½ä¸ºè´Ÿæ•°');
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * éªŒè¯è§¦å‘ç­–ç•¥é…ç½®
 */
export function validateTriggerStrategy(config: TriggerStrategyConfig): ValidationResult {
  const errors: string[] = [];

  if (!config.sourceId) {
    errors.push('å¿…é¡»é€‰æ‹©ç›‘å¬æ¥æº');
  }

  if (!config.triggerFrameId) {
    errors.push('å¿…é¡»é€‰æ‹©è§¦å‘å¸§');
  }

  if (!config.conditions || config.conditions.length === 0) {
    errors.push('è‡³å°‘éœ€è¦ä¸€ä¸ªè§¦å‘æ¡ä»¶');
  }

  if (config.conditions) {
    config.conditions.forEach((condition, index) => {
      if (!condition.fieldId) {
        errors.push(`æ¡ä»¶${index + 1}ï¼šå¿…é¡»é€‰æ‹©å­—æ®µ`);
      }
      if (!condition.value) {
        errors.push(`æ¡ä»¶${index + 1}ï¼šå¿…é¡»è®¾ç½®å€¼`);
      }
    });
  }

  if (config.responseDelay && config.responseDelay < 0) {
    errors.push('å“åº”å»¶æ—¶ä¸èƒ½ä¸ºè´Ÿæ•°');
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * éªŒè¯ç­–ç•¥é…ç½®
 */
export function validateStrategyConfig(config: StrategyConfig): ValidationResult {
  switch (config.type) {
    case 'timed':
      return validateTimedStrategy(config);
    case 'triggered':
      return validateTriggerStrategy(config);
    default:
      return { valid: false, errors: ['æœªçŸ¥çš„ç­–ç•¥ç±»å‹'] };
  }
}
```

### 3.3 é»˜è®¤é…ç½®ç”Ÿæˆå™¨

**æ–‡ä»¶ä½ç½®**: `src/utils/frames/defaultConfigs.ts`

```typescript
import { nanoid } from 'nanoid';
import type {
  TimedStrategyConfig,
  TriggerStrategyConfig,
  TriggerCondition,
} from '../../types/frames/sendInstances';

/**
 * åˆ›å»ºé»˜è®¤å®šæ—¶ç­–ç•¥é…ç½®
 */
export function createDefaultTimedConfig(): TimedStrategyConfig {
  return {
    type: 'timed',
    sendInterval: 1000, // 1ç§’
    repeatCount: 10,
    isInfinite: false,
    startDelay: 0,
  };
}

/**
 * åˆ›å»ºé»˜è®¤è§¦å‘ç­–ç•¥é…ç½®
 */
export function createDefaultTriggerConfig(): TriggerStrategyConfig {
  return {
    type: 'triggered',
    sourceId: '',
    triggerFrameId: '',
    conditions: [createDefaultTriggerCondition()],
    responseDelay: 0,
  };
}

/**
 * åˆ›å»ºé»˜è®¤è§¦å‘æ¡ä»¶
 */
export function createDefaultTriggerCondition(): TriggerCondition {
  return {
    id: nanoid(),
    fieldId: '',
    condition: 'equals',
    value: '',
    logicOperator: 'and',
  };
}

/**
 * å…‹éš†ç­–ç•¥é…ç½®
 */
export function cloneStrategyConfig<T extends TimedStrategyConfig | TriggerStrategyConfig>(
  config: T,
): T {
  return JSON.parse(JSON.stringify(config));
}
```

## 4. æ–°å¢å¤ç”¨ç»„åˆå¼å‡½æ•°

### 4.1 é…ç½®æ–‡ä»¶æ“ä½œç»„åˆå¼å‡½æ•°

**æ–‡ä»¶ä½ç½®**: `src/composables/common/useConfigFileOperations.ts`

```typescript
import { ref } from 'vue';
import type { TaskConfigFile, ConfigFileResult } from '../../types/frames/taskConfig';
import type {
  SendFrameInstance,
  InstanceTargetConfig,
  StrategyConfig,
} from '../../types/frames/sendInstances';
import { createTaskConfigFile, validateTaskConfigFile } from '../../utils/frames/taskConfigUtils';

export function useConfigFileOperations() {
  const isLoading = ref(false);
  const lastError = ref<string | null>(null);

  /**
   * ä¿å­˜é…ç½®åˆ°ç”¨æˆ·é€‰æ‹©çš„æ–‡ä»¶
   */
  async function saveConfigToUserFile(
    instances: SendFrameInstance[],
    targets: InstanceTargetConfig[],
    strategy?: StrategyConfig,
    name: string = 'ä»»åŠ¡é…ç½®',
    description?: string,
  ): Promise<ConfigFileResult> {
    isLoading.value = true;
    lastError.value = null;

    try {
      const configData = createTaskConfigFile(instances, targets, strategy, name, description);

      // ä½¿ç”¨ electron çš„æ–‡ä»¶å¯¹è¯æ¡†
      const { dialog } = window.require('electron').remote;
      const result = await dialog.showSaveDialog({
        title: 'ä¿å­˜ä»»åŠ¡é…ç½®',
        defaultPath: `${name.replace(/\s+/g, '_')}.json`,
        filters: [{ name: 'JSON æ–‡ä»¶', extensions: ['json'] }],
      });

      if (result.canceled || !result.filePath) {
        return { success: false, message: 'ç”¨æˆ·å–æ¶ˆä¿å­˜' };
      }

      // ä¿å­˜æ–‡ä»¶
      const fs = window.require('fs').promises;
      await fs.writeFile(result.filePath, JSON.stringify(configData, null, 2), 'utf-8');

      return {
        success: true,
        data: configData,
        filePath: result.filePath,
        message: 'é…ç½®ä¿å­˜æˆåŠŸ',
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : 'ä¿å­˜å¤±è´¥';
      lastError.value = message;
      return { success: false, message };
    } finally {
      isLoading.value = false;
    }
  }

  /**
   * ä»ç”¨æˆ·é€‰æ‹©çš„æ–‡ä»¶åŠ è½½é…ç½®
   */
  async function loadConfigFromUserFile(): Promise<ConfigFileResult> {
    isLoading.value = true;
    lastError.value = null;

    try {
      // ä½¿ç”¨ electron çš„æ–‡ä»¶å¯¹è¯æ¡†
      const { dialog } = window.require('electron').remote;
      const result = await dialog.showOpenDialog({
        title: 'åŠ è½½ä»»åŠ¡é…ç½®',
        filters: [{ name: 'JSON æ–‡ä»¶', extensions: ['json'] }],
        properties: ['openFile'],
      });

      if (result.canceled || !result.filePaths?.length) {
        return { success: false, message: 'ç”¨æˆ·å–æ¶ˆåŠ è½½' };
      }

      // è¯»å–æ–‡ä»¶
      const fs = window.require('fs').promises;
      const fileContent = await fs.readFile(result.filePaths[0], 'utf-8');
      const configData = JSON.parse(fileContent);

      // éªŒè¯é…ç½®æ ¼å¼
      if (!validateTaskConfigFile(configData)) {
        return { success: false, message: 'æ— æ•ˆçš„é…ç½®æ–‡ä»¶æ ¼å¼' };
      }

      return {
        success: true,
        data: configData,
        filePath: result.filePaths[0],
        message: 'é…ç½®åŠ è½½æˆåŠŸ',
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : 'åŠ è½½å¤±è´¥';
      lastError.value = message;
      return { success: false, message };
    } finally {
      isLoading.value = false;
    }
  }

  return {
    isLoading,
    lastError,
    saveConfigToUserFile,
    loadConfigFromUserFile,
  };
}
```

### 4.2 ç­–ç•¥é…ç½®ç»„åˆå¼å‡½æ•°

**æ–‡ä»¶ä½ç½®**: `src/composables/frames/useStrategyConfig.ts`

```typescript
import { ref, computed } from 'vue';
import type {
  TimedStrategyConfig,
  TriggerStrategyConfig,
  StrategyConfig,
} from '../../types/frames/sendInstances';
import { validateStrategyConfig } from '../../utils/frames/strategyValidation';
import {
  createDefaultTimedConfig,
  createDefaultTriggerConfig,
} from '../../utils/frames/defaultConfigs';

export function useStrategyConfig() {
  const timedConfig = ref<TimedStrategyConfig>(createDefaultTimedConfig());
  const triggerConfig = ref<TriggerStrategyConfig>(createDefaultTriggerConfig());
  const currentStrategyType = ref<'immediate' | 'timed' | 'triggered'>('immediate');

  // è®¡ç®—å½“å‰ç­–ç•¥é…ç½®
  const currentStrategyConfig = computed<StrategyConfig | undefined>(() => {
    switch (currentStrategyType.value) {
      case 'timed':
        return timedConfig.value;
      case 'triggered':
        return triggerConfig.value;
      default:
        return undefined;
    }
  });

  // éªŒè¯å½“å‰é…ç½®
  const validation = computed(() => {
    if (!currentStrategyConfig.value) {
      return { valid: true, errors: [] };
    }
    return validateStrategyConfig(currentStrategyConfig.value);
  });

  /**
   * è®¾ç½®ç­–ç•¥ç±»å‹
   */
  function setStrategyType(type: 'immediate' | 'timed' | 'triggered') {
    currentStrategyType.value = type;
  }

  /**
   * æ›´æ–°å®šæ—¶é…ç½®
   */
  function updateTimedConfig(config: Partial<TimedStrategyConfig>) {
    timedConfig.value = { ...timedConfig.value, ...config };
  }

  /**
   * æ›´æ–°è§¦å‘é…ç½®
   */
  function updateTriggerConfig(config: Partial<TriggerStrategyConfig>) {
    triggerConfig.value = { ...triggerConfig.value, ...config };
  }

  /**
   * é‡ç½®é…ç½®
   */
  function resetConfigs() {
    timedConfig.value = createDefaultTimedConfig();
    triggerConfig.value = createDefaultTriggerConfig();
    currentStrategyType.value = 'immediate';
  }

  /**
   * åº”ç”¨å¤–éƒ¨é…ç½®
   */
  function applyExternalConfig(strategy?: StrategyConfig) {
    if (!strategy) {
      currentStrategyType.value = 'immediate';
      return;
    }

    currentStrategyType.value = strategy.type;
    if (strategy.type === 'timed') {
      timedConfig.value = { ...strategy };
    } else if (strategy.type === 'triggered') {
      triggerConfig.value = { ...strategy };
    }
  }

  return {
    // çŠ¶æ€
    timedConfig,
    triggerConfig,
    currentStrategyType,
    currentStrategyConfig,
    validation,

    // æ–¹æ³•
    setStrategyType,
    updateTimedConfig,
    updateTriggerConfig,
    resetConfigs,
    applyExternalConfig,
  };
}
```

## 5. å¤ç”¨ç»„ä»¶è®¾è®¡

### 5.1 ç­–ç•¥é…ç½®é¢æ¿ç»„ä»¶

**æ–‡ä»¶ä½ç½®**: `src/components/frames/strategy/TimedConfigPanel.vue`

```vue
<template>
  <div class="timed-config-panel space-y-4">
    <div class="grid grid-cols-2 gap-4">
      <q-input
        v-model.number="localConfig.sendInterval"
        type="number"
        label="å‘é€é—´éš”(ms)"
        min="100"
        :rules="[(val) => val >= 100 || 'é—´éš”ä¸èƒ½å°äº100ms']"
        class="bg-industrial-panel"
      />

      <q-input
        v-model.number="localConfig.startDelay"
        type="number"
        label="å¼€å§‹å»¶æ—¶(ms)"
        min="0"
        class="bg-industrial-panel"
      />
    </div>

    <div class="flex items-center space-x-4">
      <q-checkbox v-model="localConfig.isInfinite" label="æ— é™å¾ªç¯" color="primary" />

      <q-input
        v-if="!localConfig.isInfinite"
        v-model.number="localConfig.repeatCount"
        type="number"
        label="é‡å¤æ¬¡æ•°"
        min="1"
        :rules="[(val) => val >= 1 || 'é‡å¤æ¬¡æ•°å¿…é¡»å¤§äº0']"
        class="flex-1 bg-industrial-panel"
      />
    </div>

    <!-- é…ç½®é¢„è§ˆ -->
    <div class="bg-industrial-highlight p-3 rounded text-sm">
      <div class="text-industrial-accent mb-1">é…ç½®é¢„è§ˆï¼š</div>
      <div class="text-industrial-secondary">
        æ¯ {{ localConfig.sendInterval }}ms å‘é€ä¸€æ¬¡ï¼Œ
        {{ localConfig.isInfinite ? 'æ— é™å¾ªç¯' : `é‡å¤ ${localConfig.repeatCount} æ¬¡` }}
        {{ localConfig.startDelay > 0 ? `ï¼Œå»¶æ—¶ ${localConfig.startDelay}ms å¼€å§‹` : '' }}
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import type { TimedStrategyConfig } from '../../../types/frames/sendInstances';

const props = defineProps<{
  config: TimedStrategyConfig;
}>();

const emit = defineEmits<{
  'update:config': [config: TimedStrategyConfig];
}>();

const localConfig = computed({
  get: () => props.config,
  set: (value) => emit('update:config', value),
});
</script>
```

**æ–‡ä»¶ä½ç½®**: `src/components/frames/strategy/TriggerConfigPanel.vue`

```vue
<template>
  <div class="trigger-config-panel space-y-4">
    <div class="grid grid-cols-2 gap-4">
      <q-select
        v-model="localConfig.sourceId"
        :options="sourceOptions"
        option-value="id"
        option-label="name"
        label="ç›‘å¬æ¥æº"
        emit-value
        map-options
        class="bg-industrial-panel"
      />

      <q-select
        v-model="localConfig.triggerFrameId"
        :options="frameOptions"
        option-value="id"
        option-label="name"
        label="è§¦å‘å¸§"
        emit-value
        map-options
        class="bg-industrial-panel"
      />
    </div>

    <div>
      <div class="text-subtitle2 mb-2 text-industrial-primary">è§¦å‘æ¡ä»¶</div>
      <TriggerConditionList v-model:conditions="localConfig.conditions" />
    </div>

    <q-input
      v-model.number="localConfig.responseDelay"
      type="number"
      label="å“åº”å»¶æ—¶(ms)"
      min="0"
      class="bg-industrial-panel"
    />
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import type { TriggerStrategyConfig } from '../../../types/frames/sendInstances';
import TriggerConditionList from './TriggerConditionList.vue';

const props = defineProps<{
  config: TriggerStrategyConfig;
  sourceOptions?: Array<{ id: string; name: string }>;
  frameOptions?: Array<{ id: string; name: string }>;
}>();

const emit = defineEmits<{
  'update:config': [config: TriggerStrategyConfig];
}>();

const localConfig = computed({
  get: () => props.config,
  set: (value) => emit('update:config', value),
});
</script>
```

### 5.2 é€šç”¨ç›®æ ‡é€‰æ‹©å™¨ç»„ä»¶

**æ–‡ä»¶ä½ç½®**: `src/components/common/ConnectionTargetSelector.vue`

```vue
<template>
  <q-select
    v-model="selectedTarget"
    :options="availableTargets"
    option-value="id"
    option-label="displayName"
    :label="label"
    emit-value
    map-options
    clearable
    :loading="isLoading"
    :class="componentClass"
  >
    <template #option="scope">
      <q-item v-bind="scope.itemProps">
        <q-item-section>
          <q-item-label>{{ scope.opt.name }}</q-item-label>
          <q-item-label caption>{{ scope.opt.description }}</q-item-label>
        </q-item-section>
        <q-item-section side>
          <q-badge
            :color="getStatusColor(scope.opt.status)"
            :label="getStatusLabel(scope.opt.status)"
          />
        </q-item-section>
      </q-item>
    </template>
  </q-select>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import type { ConnectionTarget, ConnectionTargetStatus } from '../../types/common/connectionTarget';

const props = defineProps<{
  modelValue?: string;
  targets: ConnectionTarget[];
  label?: string;
  size?: 'sm' | 'md' | 'lg';
  isLoading?: boolean;
}>();

const emit = defineEmits<{
  'update:modelValue': [value: string | undefined];
}>();

const selectedTarget = computed({
  get: () => props.modelValue,
  set: (value) => emit('update:modelValue', value),
});

const availableTargets = computed(() =>
  props.targets.map((target) => ({
    ...target,
    displayName: `${target.name} (${target.path || target.address || 'N/A'})`,
  })),
);

const componentClass = computed(() => {
  const sizeClasses = {
    sm: 'text-sm',
    md: '',
    lg: 'text-lg',
  };
  return `bg-industrial-panel ${sizeClasses[props.size || 'md']}`;
});

function getStatusColor(status: ConnectionTargetStatus): string {
  switch (status) {
    case 'connected':
      return 'positive';
    case 'disconnected':
      return 'warning';
    case 'error':
      return 'negative';
    default:
      return 'grey';
  }
}

function getStatusLabel(status: ConnectionTargetStatus): string {
  switch (status) {
    case 'connected':
      return 'å·²è¿æ¥';
    case 'disconnected':
      return 'æœªè¿æ¥';
    case 'error':
      return 'é”™è¯¯';
    default:
      return 'æœªçŸ¥';
  }
}
</script>
```

## 6. å¤ç”¨å®æ–½è®¡åˆ’

### 6.1 ç¬¬ä¸€é˜¶æ®µï¼šç±»å‹å®šä¹‰æ‰©å±•

1. æ‰©å±• `src/types/frames/sendInstances.ts`
2. åˆ›å»º `src/types/frames/taskConfig.ts`
3. åˆ›å»º `src/types/frames/sendTasks.ts`

### 6.2 ç¬¬äºŒé˜¶æ®µï¼šå·¥å…·å‡½æ•°åˆ›å»º

1. åˆ›å»º `src/utils/frames/taskConfigUtils.ts`
2. åˆ›å»º `src/utils/frames/strategyValidation.ts`
3. åˆ›å»º `src/utils/frames/defaultConfigs.ts`

### 6.3 ç¬¬ä¸‰é˜¶æ®µï¼šç»„åˆå¼å‡½æ•°å¼€å‘

1. åˆ›å»º `src/composables/common/useConfigFileOperations.ts`
2. åˆ›å»º `src/composables/frames/useStrategyConfig.ts`

### 6.4 ç¬¬å››é˜¶æ®µï¼šå¤ç”¨ç»„ä»¶å¼€å‘

1. åˆ›å»ºç­–ç•¥é…ç½®é¢æ¿ç»„ä»¶
2. åˆ›å»ºé€šç”¨ç›®æ ‡é€‰æ‹©å™¨ç»„ä»¶
3. é‡æ„ç°æœ‰å¯¹è¯æ¡†ä½¿ç”¨æ–°ç»„ä»¶

## 7. å¤ç”¨æ”¶ç›Šåˆ†æ

### 7.1 ä»£ç å¤ç”¨ç‡æå‡

- **ç±»å‹å®šä¹‰å¤ç”¨**: 90%ä»¥ä¸Šçš„é…ç½®ç›¸å…³ç±»å‹å¯å¤ç”¨
- **å·¥å…·å‡½æ•°å¤ç”¨**: 80%ä»¥ä¸Šçš„é…ç½®æ“ä½œé€»è¾‘å¯å¤ç”¨
- **ç»„ä»¶å¤ç”¨**: 70%ä»¥ä¸Šçš„UIç»„ä»¶å¯å¤ç”¨

### 7.2 ç»´æŠ¤æˆæœ¬é™ä½

- ç»Ÿä¸€çš„ç±»å‹å®šä¹‰å‡å°‘ç±»å‹ä¸ä¸€è‡´é—®é¢˜
- é€šç”¨çš„éªŒè¯é€»è¾‘å‡å°‘é‡å¤ä»£ç 
- æ ‡å‡†åŒ–çš„ç»„ä»¶å‡å°‘UIä¸ä¸€è‡´

### 7.3 æ‰©å±•æ€§å¢å¼º

- æ–°å¢ç­–ç•¥ç±»å‹åªéœ€æ‰©å±•ç±»å‹å®šä¹‰å’ŒéªŒè¯é€»è¾‘
- æ–°å¢é…ç½®é¡¹åªéœ€ä¿®æ”¹å¯¹åº”çš„æ¥å£å’Œç»„ä»¶
- æ–°å¢è¿æ¥ç±»å‹åªéœ€æ‰©å±•ç›®æ ‡é€‰æ‹©å™¨

é€šè¿‡ä»¥ä¸Šå¤ç”¨æ–¹æ¡ˆï¼Œå¯ä»¥å¤§å¹…æé«˜ä»£ç å¤ç”¨ç‡ï¼Œé™ä½ç»´æŠ¤æˆæœ¬ï¼Œå¢å¼ºç³»ç»Ÿçš„æ‰©å±•æ€§å’Œä¸€è‡´æ€§ã€‚
